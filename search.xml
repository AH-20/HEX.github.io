<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Grid-xor</title>
    <url>/2023/01/08/Grid-xor/</url>
    <content><![CDATA[<h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://codeforces.com/problemset/problem/1628/C">Grid Xor</a></p>
<h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>现在有矩阵A和矩阵B,矩阵B的每一个位置上的数是矩阵A这个位置的<em><strong>相邻位置</strong></em>上的数字异或和，现在给定矩阵B,求矩阵A的异或和</p>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>简单看一下这道题，我们会发现，可以通过选取B中某些数字的异或和来求出A中全部数字的异或和，例如现在给定一个$2 \times 2$的矩阵B,我们将他们的结果写出来<br>$$\begin{bmatrix}<br>a_{1,2} \bigoplus a_{2,1} &amp;a_{1,1} \bigoplus a_{2,2}\\<br>a_{1,1} \bigoplus a_{2,2}&amp;a_{2,1} \bigoplus a_{1,1}\<br>\end{bmatrix}$$<br>不难发现，当$b_{1,1}$与$b_{1,2}$的异或和恰为$a_{1,1} $^$a_{1,2}$^$a_{2,1}$^$a_{2,2}$,就是我们要求出的答案，那么我们不妨将这个问题推广到$4 \times 4$的矩阵，我们用橙黄色来表示我们选择的B中的元素，每当我们选择一个B中的元素并将他们表示为A中的元素后，我们用蓝色来表示已经异或进来的A中的元素，下面我们来实现这个过程<br> <img src="/2023/01/08/Grid-xor/Grid-xor_1.png" width="30%"><br> $\qquad$<br> <img src="/2023/01/08/Grid-xor/Grid-xor_2.png" width="30%"><br> 第一次我们选择格子$(1,1)$,此时$sum&#x3D; a_{1,2} \bigoplus a_{2,1} $</p>
<p><img src="/2023/01/08/Grid-xor/Grid-xor_3.png" width="30%">  $\qquad$<br> <img src="/2023/01/08/Grid-xor/Grid-xor_04.png" width="30%"><br> 第二次我们选择格子$(1,2)$,此时$sum&#x3D; a_{1,1} \bigoplus a_{1,2} \bigoplus a_{1,3} \bigoplus a_{2,1} \bigoplus a_{2,2}$，可以证明当n为偶数时，只要我们不断去找<em><strong>邻居格子还一个都没有被占据</strong></em>的格子并将他加入到异或和中，最终就一定可以将蓝色铺满整个矩形，亦即求出A矩阵的异或和</p>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">ll a[<span class="number">1005</span>][<span class="number">1005</span>];</span><br><span class="line">ll vis[<span class="number">1005</span>][<span class="number">1005</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ll n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;a[i][j]),vis[i][j]=<span class="number">0</span>;</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">            ll have=<span class="number">0</span>,need=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(i+<span class="number">1</span>&lt;=n) have++,need+=(vis[i+<span class="number">1</span>][j]==<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span>(i<span class="number">-1</span>&gt;=<span class="number">1</span>) have++,need+=(vis[i<span class="number">-1</span>][j]==<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span>(j+<span class="number">1</span>&lt;=n) have++,need+=(vis[i][j+<span class="number">1</span>]==<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span>(j<span class="number">-1</span>&gt;=<span class="number">1</span>) have++,need+=(vis[i][j<span class="number">-1</span>]==<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span>(need&lt;have) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">else</span> ans^=a[i][j],vis[i+<span class="number">1</span>][j]=vis[i<span class="number">-1</span>][j]=vis[i][j+<span class="number">1</span>]=vis[i][j<span class="number">-1</span>]=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ll T;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--) <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>constructive</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2023/01/06/hello-world/</url>
    <content><![CDATA[<p>Hello World!欢迎来到HEX队的博客</p>
]]></content>
  </entry>
  <entry>
    <title>Valiant&#39;s New Map</title>
    <url>/2023/01/08/Valiant-s-New-Map/</url>
    <content><![CDATA[<h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>给定一个二维矩阵，你要从中找到一个$l \times l$的子矩阵，这个矩阵中所有的元素都大于等于$l$,请问$l$的最大值是多少？</p>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>求最大值这很容易让我们联想到二分，重点在于如何在合适的复杂度内进行check,我们可以用二维前缀和去优化cehck的过程，用1表示不满足条件的元素，0表示满足条件的元素，然后查询子矩阵和，若和为0则该子矩阵符合条件</p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">ll n,m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ck</span><span class="params">(ll mid,vector&lt;vector&lt;ll&gt; &gt;a)</span></span>&#123;</span><br><span class="line">    vector&lt;vector&lt;ll&gt; &gt;<span class="built_in">sum</span>(n+<span class="number">1</span>,<span class="built_in">vector</span>&lt;ll&gt;(m+<span class="number">1</span>));<span class="comment">//二维前缀和</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">            sum[i][j]=(sum[i<span class="number">-1</span>][j]+sum[i][j<span class="number">-1</span>]-sum[i<span class="number">-1</span>][j<span class="number">-1</span>]+(a[i][j]&lt;mid));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i+mid<span class="number">-1</span>&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j+mid<span class="number">-1</span>&lt;=m;j++)&#123;</span><br><span class="line">            ll toi=i+mid<span class="number">-1</span>;</span><br><span class="line">            ll toj=j+mid<span class="number">-1</span>;</span><br><span class="line">            ll now=sum[toi][toj]-sum[toi][j<span class="number">-1</span>]-sum[i<span class="number">-1</span>][toj]+sum[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line">            <span class="keyword">if</span>(now==<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    vector&lt;vector&lt;ll&gt; &gt;<span class="built_in">a</span>(n+<span class="number">1</span>,<span class="built_in">vector</span>&lt;ll&gt;(m+<span class="number">1</span>));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;a[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ll L=<span class="number">0</span>,R=<span class="number">1e6</span>;</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(L&lt;=R)&#123;</span><br><span class="line">        ll mid=(L+R)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">ck</span>(mid,a)) L=mid+<span class="number">1</span>,ans=mid;</span><br><span class="line">        <span class="keyword">else</span> R=mid<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ll T;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--) <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="反思"><a href="#反思" class="headerlink" title="反思"></a>反思</h2><p>比赛时没有能够做出这道题时因为对<em><strong>二维前缀和</strong></em>掌握不够深刻，而是去考虑直接用树套树查询最大值，使这个问题变得太复杂，平时要加强练习才能对各种算法融会贯通</p>
]]></content>
      <tags>
        <tag>二维前缀和</tag>
      </tags>
  </entry>
  <entry>
    <title>线段树合并</title>
    <url>/2023/01/06/%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%90%88%E5%B9%B6%E4%BA%8C/</url>
    <content><![CDATA[<h2 id="例题一"><a href="#例题一" class="headerlink" title="例题一"></a>例题一</h2><h4 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h4><p><a href="https://www.luogu.com.cn/problem/P3224">HNOI2022永无乡</a></p>
<h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>首先我们看到，这道题要让我们求出给定集合内的第k小，并且支持集合的合并操作。这让我们想到可以用权值线段树进行第k小的查询，用线段树合并来完成集合的合并操作，下面我们进行代码的实现<br>首先是第k小的查询</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ll <span class="title">query</span><span class="params">(ll loc,ll cl,ll cr,ll k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tree[loc].sum&lt;k) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;<span class="comment">//如果集合中的数字小于k个，直接返回-1</span></span><br><span class="line">    <span class="keyword">if</span>(cl==cr) <span class="keyword">return</span> cl;</span><br><span class="line">    ll mid=(cl+cr)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(tree[<span class="built_in">ls</span>(loc)].sum&gt;=k) <span class="keyword">return</span> <span class="built_in">query</span>(<span class="built_in">ls</span>(loc),cl,mid,k);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">query</span>(<span class="built_in">rs</span>(loc),mid+<span class="number">1</span>,cr,k-tree[<span class="built_in">ls</span>(loc)].sum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后我们来完成集合的合并操作</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> Root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!a) <span class="keyword">return</span> b;</span><br><span class="line">    <span class="keyword">if</span>(!b) <span class="keyword">return</span> a;</span><br><span class="line">    <span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">ls</span>(a)=<span class="built_in">merge</span>(<span class="built_in">ls</span>(a),<span class="built_in">ls</span>(b),l,mid,Root);</span><br><span class="line">    <span class="built_in">rs</span>(a)=<span class="built_in">merge</span>(<span class="built_in">rs</span>(a),<span class="built_in">rs</span>(b),mid+<span class="number">1</span>,r,Root);</span><br><span class="line">    <span class="built_in">push_up</span>(a);</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;<span class="comment">//进行线段树合并</span></span><br></pre></td></tr></table></figure>
<p>以上就是解决这道题的核心代码，还有一个要注意的地方在于，当我们更新了一个岛屿所属的线段树后，要同步更新所有跟他联通的岛屿所属的线段树，这一步要通过并查集来完成,在u和v之间建桥，直接合并的并不是u和v，而是u和v所属集合在并查集上的根节点</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> ra=root[<span class="built_in">find</span>(a)];</span><br><span class="line"><span class="type">int</span> rb=root[<span class="built_in">find</span>(b)];</span><br><span class="line"><span class="built_in">Merge</span>(a,b);<span class="comment">//这是并查集的合并操作</span></span><br><span class="line"><span class="keyword">if</span>(ra==rb) <span class="keyword">continue</span>;</span><br><span class="line">root[a]=root[b]=<span class="built_in">merge</span>(ra,rb,<span class="number">1</span>,n,ra);<span class="comment">//进行合并，并更新两个树的根节点位置</span></span><br></pre></td></tr></table></figure>
<p>这样，我们便解决了这道题</p>
]]></content>
  </entry>
</search>
